# Error Handling for Precompiled Contracts

|RSKIP          |197           |
| :------------ |:-------------|
|**Title**      |Error Handling for Precompiled Contracts |
|**Created**    |15-12-2020 |
|**Author**     |FJ |
|**Purpose**    |USa |
|**Layer**      |Core |
|**Complexity** |2 |
|**Status**     |Accepted |

## Abstract

This RSKIP specifies a new expected behavior for a precompiled contract call: any expected failed call pushes a zero into the stack and reverts the state before the execution.

## Motivation

Provides a mechanisim to handle errors for precompiled calls by checking the returned state. Before Iris hardfork the transaction wasn't reverted and consumed all the remaining gas from the entire call.

Suppose that there is a Contract A that, somewhere, calls a Precompiled contract B with invalid data (or something that produces an expected failure), it's desirable to throw a kind "exception" that gives the chance to the caller (A) to handle and use it for it's own pouposes, instead of failing the entire execution.

## Specification

When `blockNumber >= IRIS_HF`, during a precompiled contract execution any expected failure should:
1. Revert the execution state.
2. Push a ZERO into the stack.

Lately this zero state can be used by the caller to decide what to do whenever it reaches the expected failed state.

Note: an expected failure should be considered by the precompiled itself, any other kind of runtime failures should still consume the entire provided gas.

### Posible Use Case 

This is a posible use case where we use a contract to perform multiple precompiled contracts calls.

```js
contract PrecompilesMultiCalls {
    address[] precompiles;

    // A function that calls multiple precompiled contracts with some particular input generated by the caller. 
    function multiplePrecompilesCalls() public returns (bool) {
        // some logic     
        
        // at some point will call the precompiles 
        for(uint i = 0; i < precompiles.length; i++) {
            uint256 retval;
            address precAddr = precompiles[i];

            assembly {
                // allocate output byte array
                let res := mload(0x40)

                // call precompile (STATICCALL returns success (1) or failure (0))
                retval := staticcall(gas(), precAddr, input, inputLen, res, outLen)
            }

            if(retval == 0) {
                // do something on failure
            } else if(retval == 1) {
                // do some other thing on success
            } else {
                // this is unexpected
            }
        }
        
        // some logic

        return true;
    }
}
```

This wouldn't have been posible, before introducing this RSKIP, because the entire execution would have failed whenever it get an error from the precompiled call.

### Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
